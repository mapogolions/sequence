'use strict';

const {
  isEmpty,
  empty,
  pure,
  cons,
  toArray,
  toSet,
  toMap,
  init,
  take,
  takeWhile,
  takenth,
  repeat,
  repeatedly,
  to,
  until,
  fold,
  foldi,
  unfold,
  append,
  length,
  nth,
  iterate,
  equal,
  iter,
  iteri,
  map,
  mapi,
  filter,
  reduce,
  forAll,
  exists,
  sum,
  max,
  min,
  zipIndex,
  zip,
  drop,
  dropWhile,
  partition,
  member,
  interleave,
  intersperse,
  scan,
  flatMap,
  cycle,
  group,
} = require('../sequence.js');

describe('check whether the iterator is empty', () => {
  test('iterator contains no-elements', () => {
    expect(isEmpty(empty)).toBe(true);
  });

  test('pure returns the iterator with one element', () => {
    expect(isEmpty(pure(1))).toBe(false);
  });

  test('cons returns the non empty iterator', () => {
    expect(isEmpty(cons(0, empty))).toBe(false);
  });
});

describe('iterator is generated by supplier', () => {
  test('indexes becomes the iterator elements', () => {
    expect(toArray(init(2, i => i))).toEqual([0, 1]);
  });
});

describe('take at most N elements', () => {
  test('the empty iterator returns nothing', () => {
    expect(toArray(take(100, empty))).toEqual([]);
  });

  test('take a few elements from the infinite sequence', () => {
    expect(toArray(take(2, repeat(1)))).toEqual([1, 1]);
  });

  test('take a negative number of elements returns nothing', () => {
    expect(toArray(take(-2, to(1, 10)))).toEqual([]);
  });
});

describe('repeat an element endlessly', () => {
  test('repeat something N times', () => {
    const iterator = take(2, repeat('foo'));
    const expected = ['foo', 'foo'];
    expect(toArray(iterator)).toEqual(expected);
  });

  test('repeatedly use result of the function call', () => {
    const iterator = take(1, repeatedly(_ => 'bar'));
    const expected = ['bar'];
    expect(toArray(iterator)).toEqual(expected);
  });

  test('cycle through the iterator infinitely', () => {
    const iterator = take(5, cycle(to(1, 2)));
    const expected = [1, 2, 1, 2, 1];
    expect(toArray(iterator)).toEqual(expected);
  });
});

describe('range from A to B including', () => {
  test('returns the range with one element', () => {
    expect(toArray(to(2, 2))).toEqual([2]);
  });

  test('returns the range ascending', () => {
    expect(toArray(to(1, 3))).toEqual([1, 2, 3]);
  });

  test('returns the range descending', () => {
    expect(toArray(to(3, 1))).toEqual([3, 2, 1]);
  });
});

describe('range from A to B excluding', () => {
  test('returns the range with no-elements', () => {
    expect(toArray(until(2, 2))).toEqual([]);
  });

  test('returns the range with one element', () => {
    expect(toArray(until(2, 3))).toEqual([2]);
  });

  test('returns the range ascending', () => {
    expect(toArray(until(1, 3))).toEqual([1, 2]);
  });

  test('returns the range descending', () => {
    expect(toArray(until(3, 1))).toEqual([3, 2]);
  });
});

describe('folding', () => {
  test('ignore index', () => {
    const result = fold((seed, x) => seed + x, 0, to(1, 4));
    expect(result).toBe(10);
  });

  test('index is passed as argument', () => {
    const result = foldi((seed, x, i) => seed + x + i, 10, to(-1, 1));
    expect(result).toBe(13);
  });
});

test('unfolding', () => {
  const f = x => (x < 5 ? { done: false, value: x + 1 } : { done: true });
  expect(toArray(unfold(f, 0))).toEqual([0, 1, 2, 3, 4]);
  expect(toArray(unfold(f, 5))).toEqual([]);
});

test('append one sequence to another', () => {
  expect(toArray(append(empty, empty))).toEqual([]);
  expect(toArray(append(empty, to(1, 2)))).toEqual([1, 2]);
  expect(toArray(append(to(1, 2), empty))).toEqual([1, 2]);
  expect(toArray(append(to(1, 2), to(3, 4)))).toEqual([1, 2, 3, 4]);
});

describe('length of an iterator', () => {
  test('length of the empty iterator is zero', () => {
    expect(length(empty)).toBe(0);
  });

  test('iterator has one element', () => {
    expect(length(pure(0))).toBe(1);
  });

  test('non empty iterator', () => {
    expect(length(to(1, 3))).toBe(3);
    expect(length(until(1, 3))).toBe(2);
  });
});

describe('n-th element(zero index base)', () => {
  test('take the second element from the iterator', () => {
    expect(nth(1, to(1, 5))).toBe(2);
    expect(nth(1, init(2, i => i))).toBe(1);
  });

  test('failure caused by a negative index', () => {
    expect(() => nth(-1, to(1, 20))).toThrowError(RangeError);
  });

  test('failure caused by too large index', () => {
    expect(() => nth(2, to(1, 2))).toThrowError(RangeError);
  });
});

test('generates infinite sequence by rule', () => {
  expect(toArray(take(5, iterate(1, x => x + 1)))).toEqual([1, 2, 3, 4, 5]);
  expect(toArray(take(3, iterate(0, x => x - 1)))).toEqual([0, -1, -2]);
});

describe('equality of iterators', () => {
  test('empty iterators are equal to each other', () => {
    expect(equal(empty, empty)).toBe(true);
  });

  test('if one of the iterators is empty', () => {
    expect(equal(pure(1), empty)).toBe(false);
    expect(equal(empty, to(1, 2))).toBe(false);
  });

  test('iterators with different length are not equal to each other', () => {
    expect(equal(to(1, 3), until(1, 3))).toBe(false);
  });

  test('iterators with different elements are not equal to each other', () => {
    expect(equal(pure(1), pure(2))).toBe(false);
    expect(equal(to(1, 2), to(2, 3))).toBe(false);
  });

  test('iterators with the same length and elements are equal', () => {
    expect(equal(to(1, 2), until(1, 3))).toBe(true);
  });
});

describe('iterator mapping', () => {
  test('mapping of the empty iterator', () => {
    expect(toArray(map(x => x, empty))).toEqual([]);
    expect(toArray(mapi((x, i) => x + i, empty))).toEqual([]);
  });

  test('strings are mapped to nums', () => {
    expect(toArray(map(x => x.length, pure('foo')))).toEqual([3]);
    expect(toArray(mapi((_, i) => i, pure(10)))).toEqual([0]);
  });
});

describe('filter out elements that do not satisfy the predicate', () => {
  test('only numbers that are greater than zero', () => {
    expect(toArray(filter(x => x > 0, to(-1, 1)))).toEqual([1]);
  });

  test('only numbers that are even', () => {
    const even = x => x % 2 === 0;
    const expected = [2, 4, 6, 8];
    expect(toArray(filter(even, until(1, 10)))).toEqual(expected);
  });
});

describe('take elements while the satisfy the predicate', () => {
  test('take while numbers are less than zero', () => {
    expect(toArray(takeWhile(x => x < 0, to(-2, 2)))).toEqual([-2, -1]);
  });

  test('take while numbers are greater than zero', () => {
    expect(toArray(takeWhile(x => x > 0, to(2, -2)))).toEqual([2, 1]);
  });

  test('nothing satisfies', () => {
    expect(toArray(takeWhile(_ => true, empty))).toEqual([]);
  });
});

describe('returns every elements of an iterator whose index is a multiple of N', () => {
  test('index must be greater than zero', () => {
    expect(() => takenth(0, to(1, 6))).toThrowError(Error);
    expect(() => takenth(-1, to(1, 6))).toThrowError(Error);
  });

  test('take each element from the iterator', () => {
    expect(toArray(takenth(1, to(1, 6)))).toEqual([1, 2, 3, 4, 5, 6]);
  });

  test('index is a multiple of N', () => {
    expect(toArray(takenth(2, to(1, 6)))).toEqual([1, 3, 5]);
  });
});

describe('sum of all elements', () => {
  test('sum of all elements of the empty iterator is zero', () => {
    expect(sum(empty)).toBe(0);
  });

  test('returns sum of a non empty iterator', () => {
    expect(sum(to(1, 4))).toBe(10);
    expect(sum(to(1, 2))).toBe(3);
  });
});

test('iterate on the iterator', () => {
  const callback = jest.fn(x => x);
  iter(callback, to(1, 3));
  expect(callback.mock.calls.length).toBe(3);
});

test('iterate on the iterator with index as argument', () => {
  const callback = jest.fn((i, _) => i);
  const expected = [[-1, 0], [0, 1], [1, 2]];
  iteri(callback, to(-1, 1));
  expect(callback.mock.calls).toEqual(expected);
});

describe('executes a reducer function on each element ', () => {
  test('reduce of the empty iterator without initial', () => {
    const reduceOfEmptyIterator = () => reduce((acc, x) => acc + x, empty);
    expect(reduceOfEmptyIterator).toThrowError(Error);
  });

  test('reduce of the empty iterator with initial', () => {
    expect(reduce((acc, x) => acc + x, empty, 11)).toBe(11);
  });

  test('reduce of the iterator without initial', () => {
    expect(reduce((acc, x) => acc + x, pure(10))).toBe(10);
    expect(reduce((acc, x) => acc + x, to(1, 2))).toBe(3);
    expect(reduce((acc, x) => acc + x, to(1, 4))).toBe(10);
  });

  test('reduce of the iterator with initial', () => {
    expect(reduce((acc, x) => acc + x, pure(10), 10)).toBe(20);
    expect(reduce((acc, x) => acc + x, to(1, 2), 100)).toBe(103);
    expect(reduce((acc, x) => acc + x, to(1, 4), 100)).toBe(110);
  });
});

test('checks whether the predicate is true for all elements', () => {
  expect(forAll(x => x < 0, to(-2, 0))).toBe(false);
  expect(forAll(x => x < 0, until(-2, 0))).toBe(true);
  expect(forAll(x => x > 0, empty)).toBe(true);
});

test('checks whether the predicate is true for at least one element', () => {
  expect(exists(x => x < 0, to(3, -1))).toBe(true);
  expect(exists(x => x < 0, until(3, -1))).toBe(false);
  expect(exists(_ => true, empty)).toBe(false);
});

test('maximum element', () => {
  expect(max(to(1, 10))).toBe(10);
  expect(max(to(10, 1))).toBe(10);
  expect(() => max(empty)).toThrowError(Error);
});

test('minimum element', () => {
  expect(min(to(1, 10))).toBe(1);
  expect(min(to(10, 1))).toBe(1);
  expect(() => min(empty)).toThrowError(Error);
});

test('zip elements with their index in the iterator', () => {
  expect(toArray(zipIndex(to(1, 3)))).toEqual([[0, 1], [1, 2], [2, 3]]);
  expect(toArray(zipIndex(empty))).toEqual([]);
});

test('combine common part of iterators', () => {
  expect(toArray(zip(to(1, 2), to(1, 3)))).toEqual([[1, 1], [2, 2]]);
  expect(toArray(zip(to(1, 10), empty))).toEqual([]);
});

test('drop N elements', () => {
  expect(toArray(drop(10, empty))).toEqual([]);
  expect(toArray(drop(0, to(1, 3)))).toEqual([1, 2, 3]);
  expect(toArray(drop(1, to(1, 3)))).toEqual([2, 3]);
  expect(toArray(drop(5, to(1, 3)))).toEqual([]);
});

test('drop elements while they satisfy the predicate', () => {
  expect(toArray(dropWhile(x => x < 0, to(-1, 1)))).toEqual([0, 1]);
  expect(toArray(dropWhile(x => x > 0, to(-1, 1)))).toEqual([-1, 0, 1]);
  expect(toArray(dropWhile(_ => true, empty))).toEqual([]);
  expect(toArray(dropWhile(_ => true, to(-1, 1)))).toEqual([]);
});

test('returns the elements that satisfy / do not satisfy the predicate', () => {
  const [success, failure] = partition(x => x < 0, to(-1, 1));
  const expectedSuccess = [-1];
  const expectedFailure = [0, 1];
  expect(toArray(success)).toEqual(expectedSuccess);
  expect(toArray(failure)).toEqual(expectedFailure);
});

describe('checks whether the given element is a member', () => {
  const eq = (a, b) => a === b ** 2;
  expect(member(eq, 9, to(1, 3))).toBe(true);
  expect(member(eq, 9, until(1, 3))).toBe(false);
});

describe('convert an iterator to a collection', () => {
  test('to array', () => {
    expect(toArray(empty)).toEqual([]);
    expect(toArray(pure(0))).toEqual([0]);
    expect(toArray(to(1, 2))).toEqual([1, 2]);
  });

  test('to set', () => {
    expect(toSet(empty)).toEqual(new Set());
    expect(toSet(to(-1, 0))).toEqual(new Set([-1, 0]));
    expect(toSet(take(10, repeat('a')))).toEqual(new Set(['a']));
  });

  test('to map', () => {
    const iterator = take(3, repeat('a'));
    const expected = new Map([[0, 'a'], [1, 'a'], [2, 'a']]);
    expect(toMap(iterator)).toEqual(expected);
    expect(toMap(empty)).toEqual(new Map());
  });
});

test('yields an element of A, then an element of B, and so on', () => {
  expect(toArray(interleave(to(1, 2), empty))).toEqual([1, 2]);
  expect(toArray(interleave(empty, to(1, 2)))).toEqual([1, 2]);
  expect(toArray(interleave(to(1, 2), pure(3)))).toEqual([1, 3, 2]);
  expect(toArray(interleave(pure(3), to(1, 2)))).toEqual([3, 1, 2]);
  expect(toArray(interleave(to(1, 2), to(3, 4)))).toEqual([1, 3, 2, 4]);
});

describe('put a separator between all elements', () => {
  test('mixed with pipe', () => {
    const iterator = intersperse('|', to(1, 3));
    const expected = '1|2|3';
    expect(toArray(iterator).join('')).toBe(expected);
  });

  test('mixed with zero', () => {
    const iterator = intersperse(0, to(1, 3));
    const expected = [1, 0, 2, 0, 3];
    expect(toArray(iterator)).toEqual(expected);
  });

  test('the empty iterator is mixed with zero', () => {
    expect(toArray(intersperse(0, empty))).toEqual([]);
  });
});

describe('scan like fold, but keeping successive values of the accumulator', () => {
  test('skan the empty iterator', () => {
    const iterator = scan((acc, x) => acc + x, null, empty);
    const expected = [];
    expect(toArray(iterator)).toEqual(expected);
  });

  test('partial sum iterator', () => {
    const iterator = scan((acc, x) => acc + x, 0, to(1, 3));
    const expected = [1, 3, 6];
    expect(toArray(iterator)).toEqual(expected);
  });
});

test('monadic bind', () => {
  expect(length(flatMap(_ => empty, to(1, 2)))).toBe(0);
  expect(length(flatMap(x => pure(x), empty))).toBe(0);
  expect(toArray(flatMap(x => pure(x), to(0, 2)))).toEqual([0, 1, 2]);
});

describe('group equal consecutive elements together', () => {
  const eq = (a, b) => a === b;
  test('nothing to group in the empty iterator', () => {
    expect(toArray(map(toArray.bind(null), group(eq, empty)))).toEqual([]);
  });

  test('elements are grouped in pairs', () => {
    const iterator = group(eq, interleave(to(1, 3), to(1, 3)));
    const expected = [[1, 1], [2, 2], [3, 3]];
    expect(toArray(map(toArray.bind(null), iterator))).toEqual(expected);
  });

  test('only consecutive elements are grouped', () => {
    const iterator = group(eq, append(to(1, 3), to(3, 1)));
    const expected = [[1], [2], [3, 3], [2], [1]];
    expect(toArray(map(toArray.bind(null), iterator))).toEqual(expected);
  });
});
